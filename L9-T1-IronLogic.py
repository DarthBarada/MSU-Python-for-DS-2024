import pytest
"""
*-----------------------*---------------------------------------*
|   Ограничение времени |   1 секунда                           |
|   Ограничение памяти  |   64Mb                                |
|   Вывод               |   стандартный вывод или output.txt    |
*-----------------------*---------------------------------------*

# Описание
Какие различные наборы логических переменных x1, x2, x3 приводят к ИСТИННОМУ значению приведенное ниже логическое высказывание?

# Формат вывода
На стандатный поток вывода или в файл output.txt выведите все наборы. Каждый набор выводится на отдельной строке. Каждый набор состоит из последовательности значений True или False, разделенных одним пробелом между собой. Для пояснения, представим, что во всех наборах False заменили на 0, True на 1. Тогда каждый набор можно рассматривать как бинарный вектор:(x1, x2, x3), где x i ∈ {0,1}. Все наборы можно отсортировать по возрастанию, если рассматривать их как числа в двоичной системе: 
    (0,0,1)
    (0,1,0)
    (0,1,1) 
    ... 
    (1,1,0) 
    (1,1,1) 

Если теперь сделать обратную замену 0 и 1 на False и True соответственно, то получилм упорядоченные наборы.

# Примечания
1. В материалах лекции решалась подобная задача поиска всех наборов значений переменных. 
2. Обратите внимание, что в данной задаче не нужно ничего передавать в качестве входных данных. 
3. Формат вывода: 
    * набор значений вида "True" или "False", разделённых пробелом, 
    * разделитель строк: символ '\n'. 

4. Выводимые значения нужно сортировать в порядке возрастания соответствующих двоичных чисел (True==1, False==0 => True>False). 
5. Примечание о значениях операторов: 
    * ¬ — логическое отрицание (not), 
    * ∧ — логическая конъюнкция (and), 
    * ∨ — логическая дизъюнкция (or). 
6. Перебор значений x 1 x1, x 2 x2, x 3 x3 может быть осуществлён как при помощи вложенных циклов, так и с помощью itertools.
7. При поиске ответа на задачу может быть полезна информация о приоритетах логических операций, определяющих порядок их выполнения: 
    * Сначала выполняются операции в скобках.
    * В каждой скобке сначала выполняются все унарные not.
    * После вычисляются все AND.
    * Затем выполняется OR.
    * Если есть несколько операций с одним приоритетом, то они выполняются слева направо.
8. Можно использовать библиотеку itertools. При этом не забывайте делать соответствующий import.
"""

def test_example():
    ...


def main() -> None:
    from itertools import product
    B = (False, True)
    count = 0
    for x1, x2, x3 in product(B, repeat=3):
        if (((not x1) and x2 and (not x3)) or ((not x1) and x2 and x3) or (x1 and (not x2) and (not x3))):
            print(str(x1), str(x2), str(x3))

if __name__ == "__main__":
    main()
